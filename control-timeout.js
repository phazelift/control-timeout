"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Generated by CoffeeScript 2.7.0
(function () {
  // control-timeout - A timeout class for controlling one or multiple timeouts.
  // MIT License
  // Copyright (c) 2016 Dennis Raymondo van der Sluis
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal
  // in the Software without restriction, including without limitation the rights
  // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  // copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  // SOFTWARE.
  var Timeout, moduleName, types;
  types = require('types.js');
  moduleName = 'control-timeout';

  Timeout = function () {
    var Timeout = /*#__PURE__*/function () {
      _createClass(Timeout, null, [{
        key: "setLog",
        value: function setLog(log) {
          return Timeout.log = types.forceFunction(log);
        }
      }]);

      function Timeout(delay) {
        _classCallCheck(this, Timeout);

        this.timeouts = {};
        this.running = {};
        this.delay = Math.abs(delay) || Timeout.delay;
      }

      _createClass(Timeout, [{
        key: "exists",
        value: function exists(id) {
          return this.timeouts.hasOwnProperty(id);
        }
      }, {
        key: "isRunning",
        value: function isRunning(id) {
          return this.running.hasOwnProperty(id);
        }
      }, {
        key: "_stopOne",
        value: function _stopOne(id) {
          if (this.isRunning(id)) {
            clearTimeout(this.running[id]);
            delete this.running[id];
          }

          return this;
        }
      }, {
        key: "stop",
        value: function stop() {
          var i, id, len;

          for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
            ids[_key] = arguments[_key];
          }

          if (!ids.length) {
            for (id in this.running) {
              this._stopOne(id);
            }
          } else {
            for (i = 0, len = ids.length; i < len; i++) {
              id = ids[i];

              this._stopOne(id);
            }
          }

          return this;
        }
      }, {
        key: "setDelay",
        value: function setDelay(id, delay) {
          if (this.exists(id)) {
            return this.timeouts[id].delay = types.forceNumber(delay, this.timeouts[id].delay);
          }
        }
      }, {
        key: "getTimeout",
        value: function getTimeout(id) {
          return this.running[id];
        }
      }, {
        key: "_setTimeout",
        value: function _setTimeout(id, action, delay) {
          var _this = this;

          return this.running[id] = setTimeout(function () {
            delete _this.running[id];
            return action();
          }, delay);
        }
      }, {
        key: "run",
        value: function run(id) {
          var ref, timeout, timeouts;
          timeouts = [];

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          if (!id) {
            ref = this.timeouts;

            for (id in ref) {
              timeout = ref[id];

              if (!this.isRunning(id)) {
                var _timeout$action;

                timeouts.push(this._setTimeout(id, (_timeout$action = timeout.action).bind.apply(_timeout$action, [null].concat(args)), timeout.delay));
              }
            }
          } else if (this.exists(id)) {
            var _this$timeouts$id$act;

            timeouts.push(this._setTimeout(id, (_this$timeouts$id$act = this.timeouts[id].action).bind.apply(_this$timeouts$id$act, [null].concat(args)), this.timeouts[id].delay));
          } else {
            Timeout.log(moduleName + ': timeout with id: "' + id + '" was not found');
          }

          switch (timeouts.length) {
            case 0:
              return null;

            case 1:
              return timeouts[0];

            default:
              return timeouts;
          }
        }
      }, {
        key: "removeAll",
        value: function removeAll() {
          this.stop();
          this.timeouts = {};
          return this;
        }
      }, {
        key: "remove",
        value: function remove() {
          var i, id, len;

          for (var _len3 = arguments.length, ids = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            ids[_key3] = arguments[_key3];
          }

          if (ids.length) {
            for (i = 0, len = ids.length; i < len; i++) {
              id = ids[i];

              this._stopOne(id);

              delete this.timeouts[id];
            }
          } else {
            Timeout.log(moduleName + ': cannot remove, invalid or non-existing timeout!');
          }

          return this;
        }
      }, {
        key: "_add",
        value: function _add(id, action, delay) {
          if (types.notString(id) || !id.length) {
            Timeout.log(moduleName + ': cannot add timeout, invalid or missing id!');
          } else if (this.exists(id)) {
            Timeout.log(moduleName + ': cannot add timeout, id: ' + id + ' exists already!');
          } else {
            this.timeouts[id] = {
              action: types.forceFunction(action),
              delay: Math.abs(types.forceNumber(delay, this.delay))
            };
          }

          return this;
        }
      }, {
        key: "add",
        value: function add(id, action, delay) {
          if (types.isObject(id)) {
            return this._add(id.id, id.action, id.delay);
          } else {
            return this._add(id, action, delay);
          }
        }
      }]);

      return Timeout;
    }();

    ;
    Timeout.log = Timeout.setLog(typeof console !== "undefined" && console !== null ? console.log : void 0);
    Timeout.delay = 0;
    return Timeout;
  }.call(this);

  module.exports = Timeout;
}).call(void 0);