// Generated by CoffeeScript 1.10.0
(function() {
  var Timeout, types,
    slice = [].slice;

  types = require('types.js');

  Timeout = (function() {
    Timeout.log = types.forceFunction(typeof console !== "undefined" && console !== null ? console.log : void 0);

    Timeout.delay = 0;

    function Timeout(delay) {
      this.timeout = {};
      this.running = {};
      this.delay = (Math.abs(delay)) || Timeout.delay;
    }

    Timeout.prototype.exists = function(id) {
      return this.timeout.hasOwnProperty(id);
    };

    Timeout.prototype.isRunning = function(id) {
      return this.running.hasOwnProperty(id);
    };

    Timeout.prototype.stopOne = function(id) {
      if ((id = types.forceString(id)) && this.isRunning(id)) {
        clearTimeout(this.running[id]);
        delete this.running[id];
      }
      return this;
    };

    Timeout.prototype.stop = function() {
      var i, id, ids, len;
      ids = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!ids.length) {
        for (id in this.running) {
          this.stopOne(id);
        }
      } else {
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          this.stopOne(id);
        }
      }
      return this;
    };

    Timeout.prototype.setDelay = function(id, delay) {
      if (this.exists(id)) {
        return this.timeout[id].delay = types.forceNumber(delay, this.timeout[id].delay);
      }
    };

    Timeout.prototype.setTimeout = function(id, action, delay) {
      this.running[id] = setTimeout((function(_this) {
        return function() {
          delete _this.running[id];
          return action();
        };
      })(this), delay);
      return this;
    };

    Timeout.prototype.run = function() {
      var args, id, ref, ref1, ref2, timeout;
      id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (types.isString(id) && (this.exists(id)) && (!this.isRunning(id))) {
        this.setTimeout(id, (ref = this.timeout[id].action).bind.apply(ref, [this].concat(slice.call(args))), this.timeout[id].delay);
      } else {
        ref1 = this.timeout;
        for (id in ref1) {
          timeout = ref1[id];
          if (!this.isRunning(id)) {
            this.setTimeout(id, (ref2 = timeout.action).bind.apply(ref2, [this].concat(slice.call(args))), timeout.delay);
          }
        }
      }
      return this;
    };

    Timeout.prototype.removeAll = function() {
      this.stop();
      this.timeout = {};
      return this;
    };

    Timeout.prototype.remove = function() {
      var i, id, ids, len;
      ids = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (ids.length) {
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          this.stopOne(id);
          delete this.timeout[id];
        }
      } else {
        Timeout.log('cannot remove invalid or non-existing timeout!');
      }
      return this;
    };

    Timeout.prototype.add = function(id, action, delay) {
      var settings, timeout;
      settings = types.forceObject(id);
      if (!types.forceString(id, settings.id)) {
        Timeout.log('cannot add timeout, invalid or missing arguments!');
        return this;
      }
      timeout = {
        action: types.forceFunction(action, settings.action),
        delay: Math.abs(types.forceNumber(delay, 0) || types.forceNumber(settings.delay, this.delay))
      };
      id = types.forceString(id) || settings.id;
      if (this.exists(id)) {
        Timeout.log('cannot add timeout, id: ' + id + ' exists already!');
      } else {
        this.timeout[id] = timeout;
      }
      return this;
    };

    return Timeout;

  })();

  module.exports = Timeout;

}).call(this);
